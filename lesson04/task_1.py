import cProfile

# Первый вариант - цикл

def first(user_input):
    result = ''
    for i in user_input:
        result = f'{i}{result}'
    return result

# Замеры

# "task_1.first('65748')"
# 1000 loops, best of 5: 604 nsec per loop

# "task_1.first('65748392012938475658')"
# 1000 loops, best of 5: 1.64 usec per loop

# "task_1.first('6574839201293847023874023476503274560236455658')"
# 1000 loops, best of 5: 3.67 usec per loop

cProfile.run('first("6574839201293847023874023476503274560236455658")')

# 4 function calls in 0.000 seconds for all numbers

# Второй вариант - рекурсия

def second(num):
    if num == 0:
        return ""
    return str(num % 10) + (second((num // 10)))


# "task_1.second(65748)"
# 1000 loops, best of 5: 1.96 usec per loop

# "task_1.second(65748392012938475658)"
# 1000 loops, best of 5: 7.75 usec per loop

# "task_1.second(6574839201293847023874023476503274560236455658)"
# 1000 loops, best of 5: 19.5 usec per loop

cProfile.run('second(6574839201293847023874023476503274560236455658)')

# 6/1    0.000    0.000    0.000    0.000 prob_02.py:8(second) 65748
# 21/1    0.000    0.000    0.000    0.000 prob_02.py:8(second) 65748392012938475658
# 47/1    0.000    0.000    0.000    0.000 prob_02.py:8(second) 6574839201293847023874023476503274560236455658

# Третий вариант - срез

def third (num):
    return str(num)[::-1]

# "task_1.third(65748)"
# 1000 loops, best of 5: 311 nsec per loop

# "task_1.third(65748392012938475658)"
# 1000 loops, best of 5: 369 nsec per loop

# "task_1.third(6574839201293847023874023476503274560236455658)"
# 1000 loops, best of 5: 441 nsec per loop

cProfile.run('third(65748392012938475658)')

# 4 function calls in 0.000 seconds for all numbers

"""
Первое место по времени занял срез, это логично - встренные функции, как правило, наиболее быстрые. сложность
алгоритма О(n) - количество операций зависит от входных данных, по ним совершается 1 проход.
Второе место по времени выполнения занимает цикл. Сложность, как и в случае со срезами, описывается как O(n), т.к. 
количество вызовов функции прямо пропорционально поданным данным, производится 1 операция с каждым из элементов.
Третье место занимает рекурсия, т.к. требуется обрабатывать стек в ходе выполнения. Несмотря на это, сложность рекурсии 
составляет O(n). При входном числе из 5 знаков производится 6 вызовов. Двадцатизначное число обрабатывается 21 вызовом. 
Иными словами, сложность O(n+1), но константная сложность не учитывается и отбрасывается при итоговой оценке. 
"""
